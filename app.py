# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zuvzcePnDdMyg66xmb0UvRZQPfc0gmTL
"""

import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
from sklearn.metrics.pairwise import cosine_similarity
import spacy
from transformers import pipeline
import streamlit as st

# Carregar modelo de lematização
nlp = spacy.load("pt_core_news_sm")

# Definição das características
caracteristicas_positivas = {
    "Um calor reconfortante se espalhando pelo rosto": ("Calma", 0.7),
    "Uma energia pulsante que percorre todo o seu corpo": ("Alegria", 0.8),
    "Um longo descanso depois de uma guerra árdua": ("Alívio", 0.6),
    "O ato de cuidar de algo na esperança que vai retornar": ("Amor", 0.9),
    "Uma coisa boa que vem de dentro, sorriso vai no rosto incontrolavelmente": ("Alegria", 0.8),
    "Parece que nada me abala, nem a tempestade, nem a chuva mais fina": ("Alívio", 0.9),
    "A certeza que pode vir a guerra, que a vitória é sua": ("Alegria", 0.9),
    "Como se fosse para ajudar alguém puxar algo, ao invés de deixar ela carregar sozinha": ("Amor", 0.95),
    "Querer ver as coisas acontecerem no seu tempo, mas acontecer": ("Calma", 0.7),
    "Como se estivesse algum herói, um espelho que quero ser": ("Admiração", 0.6)
}

caracteristicas_negativas = {
    "como uma névoa densa que envolve o coração, obscurecendo a luz": ("Tristeza", 0.4),
    "um labirinto escuro, com corredores sombrios": ("Medo", 0.1),
    "fogo voraz que consome a alma, deixando apenas brasas": ("Raiva", 0.3),
    "uma névoa densa que turva a visão da compaixão": ("Nojo", 0.2),
    "uma tempestade silenciosa que desaba dentro do peito": ("Tristeza", 0.0),
    "uma sombra que paira sobre os passos, distorcendo os reflexos da confiança": ("Medo", 0.4),
    "um relógio descompassado, onde cada tic-tac ressoa como um eco de incerteza": ("Medo", 0.4),
    "um deserto vasto e silencioso": ("Tristeza", 0.4),
    "um veneno insidioso que se insinua nas brechas da alma": ("Desprezo", 0.2),
    "uma maré crescente dentro do peito": ("Tristeza", 0.6)
}

# Função para lematizar o texto
def lematizar(texto):
    doc = nlp(texto)
    return " ".join([token.lemma_ for token in doc])

# Preparar os dados
def preparar_dados(caracteristicas_positivas, caracteristicas_negativas):
    caracteristicas = {**caracteristicas_positivas, **caracteristicas_negativas}
    frases = []
    rotulos = []

    for frase, (sentimento, peso) in caracteristicas.items():
        frases.append(frase)
        rotulos.append(sentimento)

    vetorizador = TfidfVectorizer()
    X = vetorizador.fit_transform([lematizar(frase) for frase in frases])

    sentimentos_unicos = list(set(rotulos))
    rotulos_numeros = np.array([sentimentos_unicos.index(r) for r in rotulos])

    return X, rotulos_numeros, vetorizador, sentimentos_unicos

X, rotulos_numeros, vetorizador, sentimentos_unicos = preparar_dados(caracteristicas_positivas, caracteristicas_negativas)

# Treinamento do modelo
modelo = RandomForestClassifier(n_estimators=100, random_state=42)
modelo.fit(X, rotulos_numeros)

# Função para calcular similaridade de cosseno
def calcular_similaridade(texto, lista_caracteristicas):
    vetor_texto = vetorizador.transform([lematizar(texto)])
    matriz_caracteristicas = vetorizador.transform(lista_caracteristicas.keys())
    similaridades = cosine_similarity(vetor_texto, matriz_caracteristicas)
    return similaridades.ravel()

# Função para prever o sentimento mais próximo usando ML
def prever_sentimento(texto):
    texto_lematizado = lematizar(texto)
    vetor_texto = vetorizador.transform([texto_lematizado])
    predicao = modelo.predict(vetor_texto)
    sentimento_predito = sentimentos_unicos[predicao[0]]
    st.write(f"Sentimento predito: {sentimento_predito}")

    # Combine as características positivas e negativas
    caracteristicas = {**caracteristicas_positivas, **caracteristicas_negativas}

    caracteristicas_correspondentes = {k: v for k, v in caracteristicas.items() if v[0] == sentimento_predito}
    similaridades = calcular_similaridade(texto_lematizado, caracteristicas_correspondentes)

    indice_sentimento = np.argmax(similaridades)
    sentimento_proximo = list(caracteristicas_correspondentes.keys())[indice_sentimento]
    similaridade_proxima = similaridades[indice_sentimento]

    st.write(f"{sentimento_proximo}: {similaridade_proxima:.2f}")

# Função para gerar relatório de métricas
def gerar_relatorio_metrico():
    predicoes = modelo.predict(X)
    st.write(classification_report(rotulos_numeros, predicoes, target_names=sentimentos_unicos))

# Carregar o pipeline para análise de sentimento
modelo_llm = pipeline("sentiment-analysis")

# Função para prever o sentimento usando o modelo LLM
def prever_sentimento_llm(texto):
    resultados = modelo_llm(texto)
    sentimento_predito = resultados[0]['label']

    # Inverter manualmente os sentimentos, se necessário
    if sentimento_predito == "POSITIVE":
        sentimento_predito = "NEGATIVE"
    elif sentimento_predito == "NEGATIVE":
        sentimento_predito = "POSITIVE"

    return sentimento_predito

# Menu inicial do Streamlit
def menu():
    st.title("Análise de Sentimentos")
    st.write("Selecione uma opção do menu abaixo:")

    opcao = st.selectbox("Escolha uma opção:",
                         ["Características positivas",
                          "Características negativas",
                          "Digitar uma frase e prever o sentimento (Machine Learning)",
                          "Digitar uma frase e prever o sentimento (LLM)",
                          "Gerar relatório de métricas",
                          "Sair"])

    if opcao == 'Características positivas':
        st.write("\nCaracterísticas Positivas:")
        for i, caracteristica in enumerate(caracteristicas_positivas.keys(), 1):
            st.write(f"{i}. {caracteristica}")
        escolhas_positivas = st.multiselect("Escolha até 3 características:", list(caracteristicas_positivas.keys()))
        if len(escolhas_positivas) > 0:
            prever_sentimento(' '.join(escolhas_positivas))
    elif opcao == 'Características negativas':
        st.write("\nCaracterísticas Negativas:")
        for i, caracteristica in enumerate(caracteristicas_negativas.keys(), 1):
            st.write(f"{i}. {caracteristica}")
        escolhas_negativas = st.multiselect("Escolha até 3 características:", list(caracteristicas_negativas.keys()))
        if len(escolhas_negativas) > 0:
            prever_sentimento(' '.join(escolhas_negativas))
    elif opcao == 'Digitar uma frase e prever o sentimento (Machine Learning)':
        frase = st.text_input("Digite uma frase:")
        if frase:
            prever_sentimento(frase)
    elif opcao == 'Digitar uma frase e prever o sentimento (LLM)':
        frase = st.text_input("Digite uma frase:")
        if frase:
            sentimento = prever_sentimento_llm(frase)
            st.write(f"Sentimento predito pelo LLM: {sentimento}")
    elif opcao == 'Gerar relatório de métricas':
        gerar_relatorio_metrico()
    elif opcao == 'Sair':
        st.write("Saindo...")

if __name__ == "__main__":
    menu()